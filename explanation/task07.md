# task07

Что выведет программа?

Объяснить работу конвейера с использованием select.

```go
package main

import (
  "fmt"
  "math/rand"
  "time"
)

func asChan(vs ...int) <-chan int {
  c := make(chan int)
  go func() {
    for _, v := range vs {
      c <- v
      time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond)
    }
  close(c)
}()
  return c
}

func merge(a, b <-chan int) <-chan int {
  c := make(chan int)
  go func() {
    for {
      select {
        case v, ok := <-a:
          if ok {
            c <- v
          } else {
            a = nil
          }
        case v, ok := <-b:
          if ok {
            c <- v
          } else {
            b = nil
          }
        }
        if a == nil && b == nil {
          close(c)
          return
        }
     }
   }()
  return c
}

  func main() {
    rand.Seed(time.Now().Unix())
    a := asChan(1, 3, 5, 7)
    b := asChan(2, 4, 6, 8)
    c := merge(a, b)
    for v := range c {
    fmt.Print(v)
  }
}
```

Программа выведет последовательность цифр от 1 до 8 в случайном порядке, например:
```
13245678
```

Объяснение работы конвейера с использованием select:
```
1.
asChan(vs ...int) <-chan int:

Эта функция принимает переменное число целочисленных аргументов (vs ...int) и возвращает канал, из которого можно только читать (<-chan int).
Внутри функции запускается горутина (go func() { ... }).
Горутина перебирает входные значения (vs).
Для каждого значения v, она отправляет его в канал c (c <- v).
После отправки значения, горутина приостанавливается на случайное время (от 0 до 1000 миллисекунд) с помощью time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond). Это имитирует некоторую работу, которую нужно выполнить с каждым значением. Самое главное, это вносит случайность в порядок отправки данных в канал.
После отправки всех значений, горутина закрывает канал c (close(c)). Это сигнализирует, что больше значений в канал поступать не будет. Важно закрывать канал, иначе приемник будет ждать бесконечно.
Функция возвращает канал c.

2.
merge(a, b <-chan int) <-chan int:

Эта функция принимает два канала только для чтения (a и b) и возвращает канал только для чтения.
Она создает новый канал c.
Запускается горутина, которая читает значения из каналов a и b и отправляет их в канал c. Эта горутина сливает данные из двух входных каналов в один выходной канал.
Ключевым элементом является оператор select. select позволяет горутине одновременно слушать несколько каналов. Он выбирает случайным образом один из каналов, готовых к чтению, и выполняет соответствующий case.
В каждом case, если канал готов к чтению (ok == true), значение v отправляется в выходной канал c.
Если канал закрыт (ok == false), переменной канала присваивается nil. Это прекращает попытки чтения из этого канала в последующих итерациях select. Попытка чтения из nil канала приводит к немедленной блокировке.
Горутина завершает свою работу и закрывает выходной канал c (close(c)) только тогда, когда оба входных канала a и b закрыты (a == nil && b == nil).

3.
main():

Инициализируется генератор случайных чисел с помощью rand.Seed(time.Now().Unix()). Это важно для получения разных результатов при каждом запуске программы.
Создаются два канала a и b с помощью asChan, которые заполняются числами от 1 до 8.
Канал c создается путем слияния каналов a и b с помощью функции merge.
Цикл for v := range c перебирает значения из канала c до тех пор, пока канал не будет закрыт.
Для каждого полученного значения v, программа выводит его на экран (fmt.Print(v)).
```